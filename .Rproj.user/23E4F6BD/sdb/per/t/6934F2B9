{
    "contents" : "#' Generalized sorting of R objects\n#'\n#' A generalized insertion sort that works on all data types.  Using this\n#' as a replacement to sort or order would be an inefficient choice.\n#' However, implementing complex distance algorithms allows for unusual\n#' applications, such as arbitrary sorting, clustering, and solving the\n#' travelling salesman problem.\n#' @name isort\n#' @docType package\n#' @import rowr\nNULL\n\n\n#' Vectorize a scalar function to work on any R object.\n#' \n#' Robust alternative to \\code{\\link{Vectorize}} function that accepts any function with two \n#' or more arguments.  Returns a function that will work an arbitrary number of vectors, lists or \n#' data frames, though output may be unpredicatable in unusual applications.  The \n#' results are also intended to be more intuitive than Vectorize.\n#' \n#' @param fun a two or more argument function\n#' @param type like \\code{MARGIN} in \\code{\\link{apply}}, except that \\code{c(1,2)} is\n#'   represented as a \\code{3} instead.  By default, will \\code{Reduce} single dimensional\n#'   data handle everything else row-wise.\n#' @export\n#' @examples\n#' vectorize(`+`)(c(1,2,3))\n#' vectorize(sum)(c(1,2,3),c(1,2,3))\n#' # Compare these results to Vectorize, which does not vectorize sum at all.\n#' Vectorize(sum)(c(1,2,3),c(1,2,3))\n#' # Across data frame columns.\n#' df<-data.frame(a=c(1,2,3),b=c(1,2,3))\n#' vectorize(sum)(df$a,df$b)\n#' # Once again, Vectorize gives a different result\n#' Vectorize(sum)(df$a,df$b)\n#' # Any combination of vectors, lists, matrices, or data frames an be used.\n#' vectorize(`+`)(c(1,2,3),list(1,2,3),cbind(c(1,2,3)))\ndistances<-function()\n{\n  function(distance)\n  {\n    function(data,compare)\n    {\n      if(is.null(nrow(data))|len(data)==1)\n      {\n        results<-distance(data,compare)\n      }\n      else\n      {\n        results<-rowApply(data,function (x) distance(x,compare))\n      }\n      return(results)\n    }\n  }\n}\n\nneighborDistances<-function()\n{\n  function(distance)\n  {\n    function(data)\n    {\n      if(len(data)<2)\n        result<-0\n      else\n        result<-rollApply(data,window=2,minimum=1,align='right', fun=function (data) distance(head(data,1),tail(data,1)))  \n      return(buffer(result,length.out=len(data),fill=0))\n    }\n  }\n}\n\ninsert<-function()\n{\n  function(distances)\n  {\n    function(data,insert)\n    {\n      ##Get old stances\n      oldDistances<-c(data[['distances']],0)\n      ##Get distances between new object and old list\n      insertDistances<-c(0,distances(data,insert))\n      ##Determine combined distance increase\n      combinedDistances<-rollApply(insertDistances,window=2,minimum=1,align='left',sum)\n      ##Determine combined change in distances\n      deltaDistances<-combinedDistances-oldDistances\n      ##Insert where delta is smallest\n      insertIndex=which.min(deltaDistances)\n      result<-insertRow(data,insert,insertIndex)\n      ##Update distances\n#       print('Next')\n#       print(as.list(environment()))\n      result[insertIndex,'distances']<-insertDistances[insertIndex]\n      if(isTRUE(insertIndex<length(insertDistances)))\n        result[insertIndex+1,'distances']<-insertDistances[insertIndex+1]\n      return(result)      \n    }\n  }\n}\n\ninsert<-function()\n{\n  function(distance)\n  {\n    function(data,insert)\n    {\n      ##Get old stances\n      oldDistances<-c(data[['distances']],0)\n      headInsertDistances<-c(0,distances()(distance)(data,head(insert,n=1)))\n      tailInsertDistances<-c(distances()(distance)(data,tail(insert,n=1)),0)\n      ##Determine combined distance increase\n      combinedDistances<-headInsertDistances+tailInsertDistances\n      ##Determine combined change in distances\n      deltaDistances<-combinedDistances-oldDistances\n      ##Insert where delta is smallest\n      insertIndex=which.min(deltaDistances)\n      result<-insertRows(data,insert,insertIndex)\n      ##Update distances\n      #       print('Next')\n            \n      result[insertIndex,'distances']<-headInsertDistances[insertIndex]\n      if(isTRUE(insertIndex<len(result)))\n        result[insertIndex+len(insert),'distances']<-tailInsertDistances[insertIndex]\n#       print(as.list(environment()))\n      return(result)      \n    }\n  }\n}\n\n#' Vectorize a scalar function to work on any R object.\n#' \n#' Robust alternative to \\code{\\link{Vectorize}} function that accepts any function with two \n#' or more arguments.  Returns a function that will work an arbitrary number of vectors, lists or \n#' data frames, though output may be unpredicatable in unusual applications.  The \n#' results are also intended to be more intuitive than Vectorize.\n#' \n#' @param fun a two or more argument function\n#' @param type like \\code{MARGIN} in \\code{\\link{apply}}, except that \\code{c(1,2)} is\n#'   represented as a \\code{3} instead.  By default, will \\code{Reduce} single dimensional\n#'   data handle everything else row-wise.\n#' @export\n#' @examples\n#'insertionSort()(function (x,y) abs(x$FTSE-y$FTSE))(EU[1:100,])\n#'packages<-as.data.frame(available.packages())\n#'packages$Depends<-substring(packages$Depends,0,60)\n#'require(stringdist)\n#'insertionSort()(function (x,y) stringdist(x$Suggests,y$Suggests,method='jaccard',q=1,useBytes=TRUE))(packages[1:400,c('Package','Suggests')])\ninsertionSort<-function()\n{\n  function(distance)\n  {\n    function(data)\n    {\n      ##Convert to standard data type\n      data<-buffer(data,preserveClass=FALSE)\n      ##Add distance column\n      data$distances<-0\n      dataList<-split(data,1:nrow(data))\n      result<-Reduce(insert()(distance),dataList)\n      return(result)\n    }\n  }\n}\n\nsplitWhere<-function(condition)\n{\n  function(data)\n  {\n    matches<-(condition(data)*1)\n    result<-split(data,cumsum(matches))\n    return(result)\n  }\n}\n\ninsertRow <- function(existingDF, newrow, r) {\n  existingDF <- rbind(existingDF,newrow)\n  existingDF <- existingDF[order(c(1:(nrow(existingDF)-1),r-0.5)),]\n  row.names(existingDF) <- 1:nrow(existingDF)\n  return(existingDF)  \n}\n\ninsertRows <- function(existingDF, newDF, r) {\n  colnames(newDF)<-colnames(existingDF)\n  result<-rbind(existingDF,newDF)\n  sizeA<-len(existingDF)\n  sizeB<-len(newDF)\n  order1<-c(seq_len(sizeA),rep.int(r,sizeB))\n  order2<-c(rep.int(sizeB+1,sizeA),seq_len(sizeB))\n  return(result[order(order1,order2),,drop=FALSE])\n}\n\nbinarySplit<-function(threshold)\n{\n  function(distance)\n  {\n    function(data,compare)\n    {\n      if(len(data<threshold))\n        return(insertionSort()(distance)(data))\n      splitDistances<-distance(data,compare)\n      splits<-splitDistances>median(splitDistances)\n      result<-split(data,splits)\n      return(result)\n    }\n  }\n}\n\nsplitRecurse<-function(threshold)\n{\n  function(distance)\n  {\n    function(data)\n    {\n      if(len(data)<threshold)\n        return(insertionSort()(distance)(data))\n      compare<-rows(data,sample(1:len(data),1))\n      splitDistances<-distance(data,compare)\n      splits<-splitDistances>median(splitDistances)\n      dataList<-split(data,splits)\n      result<-lapply(dataList,splitRecurse(threshold)(distance))\n      #result<-mergeTree()(distance)(result[[1]],result[[2]])\n      result<-rbind(result[[1]],result[[2]])\n      return(result)\n    }\n  }\n}\n\nconnectTree<-function()\n{\n  function(distance)\n  {\n    function(tree1,tree2)\n    {\n      head1<-head(tree1,n=1)\n      head2<-head(tree2,n=1)\n      tail1<-tail(tree1,n=1)\n      tail2<-tail(tree2,n=1)\n      distance1<-distance(head1,head2)\n      distance2<-distance(head1,tail2)\n      distance3<-distance(head2,tail1)\n      #print(as.list(environment()))\n      if(min(distance1,distance2,distance3)==distance1)\n        result<-rbind(rev(tree1),tree2)\n      if(min(distance1,distance2,distance3)==distance2)\n        result<-rbind(tree2,tree1)\n      if(min(distance1,distance2,distance3)==distance3)\n        result<-rbind(tree1,tree2)\n      return(result)\n      \n    }\n  }\n}\n\nresort<-function(condition)\n{\n  function(distance)\n  {\n    function(data)\n    {\n      data$distances<-neighborDistances()(distance)(data)\n      dataList<-splitWhere(condition)(data)\n      result<-Reduce(insert()(distance),dataList)\n      return(result)\n    }\n  }\n}\n\nbinarySort<-function(threshold=100)\n{\n  function(distance)\n  {\n    function(data)\n    {\n      result<-splitRecurse(threshold)(distance)(data)\n      return(result)\n    }\n  }\n}\n",
    "created" : 1408483900896.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4030163492",
    "id" : "6934F2B9",
    "lastKnownWriteTime" : 1409256042,
    "path" : "~/Analytics/Source/isort/R/isort.R",
    "project_path" : "R/isort.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}